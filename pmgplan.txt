; if the frame changed or the vertical position changed
; then we redraw.   This should be evaluated earlier
; then reflected in the vsPmgSeqRedraw flag

; Like so:

	lda currentframe,x
	cmp prevframe,x
	bne definitelyredraw

	lda prevvpos,x
	cmp newvpos,x
	bne definitelyredraw


; Do PMG Redraw
; ENTRY
;
; X = current pmobject. (also in zbPmgCurrentIdent)
; 

libPmgSeqRedraw 

	lda vsPmgSeqRedraw,x
	bne bPmgRedraw
	rts ; nothing_to_do

bPmgRedraw

	lda #0               ; Turn off Redraw flag
	sta vsPmgSeqRedraw,x

	; shortcut to blanking the frame... do we need it?
;	ldy vsSeqIdent,x
;	cpy #SEQBLANKFRAME
;	beq libPmgZeroVposToFrameHeight ; use the current vpos and frame height to zero the bytes
                                    ; which is a problem, because those come from the sequence


	ldy vsPmgIdent,x ; get current P/M graphics (hardware) ID
	cmp #PMGNOOBJECT ; not assigned to a P/M object.

	bne bContinueRedraw

	rts ; no p/m object defined means no redraw.

bContinueRedraw

	; Get the Frame address and height

	ldy vsSeqFrameCurrent,x
    lda vsFrameAddrLo,y
	sta zwFrameAddr
	lda vsFrameAddrHi,y
	sta zwFrameAddr+1

	lda vsFrameHeight,y
	sta zwFrameHeight

; Load zwPmgAddr with address of image in P/M memory.
; This means the real vertical position plus the base 
; address of one of the PM graphics object memory maps.
; Note that coordinates plus the low byte of the 
; address to the memory map will not exceed the range
; of the one-byte value range.  (In other words, the 
; math never carries to the high byte).

; The memory management of the Player/Missile is different
; depending on the direction of movement.   When the image
; moves up the screen, then routine draws the image first
; and erases the exposed remains of the previous frame at 
; the botttom. When the image moves down the reverse occurs:
; the routine must erase the trailing residue first at the 
; top, then copy the image data into memory at the new position.

; Therefore the "start" of the P/M address is based on the 
; previous vertical position when the new image location 
; moves down the screen, and on the new vertical position 
; when the new image moves up the screen.

; High byte is always from the table.
	lda vsPmgRamAddrHi,y
	sta zwPmgAddr+1

; Which direction?
	lda vsPmgPrevVPos,x
	cmp vsPmgRealVPos,x
	beq bRedrawCurrentPosition ; prev = new
	bcc bRedrawMoveDown        ; prev < new
	bcs bRedrawMoveUp          ; prev > new


5 from  to
6  .     * 
7  .     *
8  *     *
9  *     .
10 *     .

prevvpos=8
newvpos=6
frameheight=3
anim_adr
pm_adr
blank_at_end = prevpos-newvpos =2


bRedrawMoveUp
	lda vsPmgRealVPos,x

; For Single Line Resolution
; if PMG_RES=PM_1LINE_RESOLUTION then low byte = real vpos

; For Double Line Resolution:
.if PMG_RES=PM_2LINE_RESOLUTION then low byte = real vpos + pmadr low byte
	clc
	adc vsPmgRamAddrLo,y
.endif

	sta zwPmgAddr  ; save low byte of starting address

	clc 
	lda vsPmgPrevVPos,x
	sbc vsPmgRealVPos,x
	sta zbPmgLinesToZero

	ldx zwFrameHeight
	jsr libPmgCopyFrameToPM
    
	ldx zbPmgLinesToZero
	jsr libPmgZeroLinesToPM

	rts
    

bRedrawMoveDown 
	lda vsPmgPrevVPos,x

; For Single Line Resolution
; if PMG_RES=PM_1LINE_RESOLUTION then low byte = prev vpos

; For Double Line Resolution:
.if PMG_RES=PM_2LINE_RESOLUTION then low byte = prev vpos + pmadr low byte
	clc
	adc vsPmgRamAddrLo,y
.endif

	sta zwPmgAddr

	clc 
	lda vsPmgRealVPos,x
	sbc vsPmgPrevVPos,x
	sta zbPmgLinesToZero

	tax
	jsr libPmgZeroLinesToPMTop

	ldx zwFrameHeight
	jsr libPmgCopyFrameToPM
    
	rts


; Copy the current Frame data to P/M memory.
;
; zwFrameAddr = Address of frame image
; zwPmgAddr   = Address in P/M memory to begin.  (PMADR+VPos)
;
; X = frame height

libPmgCopyFrameToPM
	ldy #0
loop_copy_frame_to_pmg
	lda (zwFrameAddr),y
	sta (zwPmgAddr),y
	iny
	dex ; frame height
	bne loop_copy_frame_to_pmg
	rts

; X = height
libPmgZeroLinesToPMTop
	lda #0
loop_zero_lines_to_pmg
	sta (zwPmgAddr),y
	inc zwPmgAddr
	dex ; height
	bne loop_zero_lines_to_pmg

	rts

libPmgZeroLinesToPMBottom
;	ldy #0
	lda #0
loop_zero_lines_to_pmg
	sta (zwPmgAddr),y
	iny
	dex ; height
	bne loop_zero_lines_to_pmg
        
	rts


libPmgZeroVposToFrameHeight

